// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ib/ffi/compute/v3_3_0/compute.proto

#ifndef PROTOBUF_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto__INCLUDED
#define PROTOBUF_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace ib {
namespace ffi {
namespace compute {
namespace v3_3_0 {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
void protobuf_AssignDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
void protobuf_ShutdownFile_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();

class FullSweepArgs;
class FullSweepResult;
class AssayConfiguration;
class QuantitatedSample;
class QuantitatedCompound;
class QuantitatedChromatogram;
class ConvertedSample;
class ConvertedChromatogram;

// ===================================================================

class FullSweepArgs : public ::google::protobuf::Message {
 public:
  FullSweepArgs();
  virtual ~FullSweepArgs();
  
  FullSweepArgs(const FullSweepArgs& from);
  
  inline FullSweepArgs& operator=(const FullSweepArgs& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FullSweepArgs& default_instance();
  
  void Swap(FullSweepArgs* other);
  
  // implements Message ----------------------------------------------
  
  FullSweepArgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FullSweepArgs& from);
  void MergeFrom(const FullSweepArgs& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .ib.ffi.compute.v3_3_0.AssayConfiguration assay_config = 1;
  inline bool has_assay_config() const;
  inline void clear_assay_config();
  static const int kAssayConfigFieldNumber = 1;
  inline const ::ib::ffi::compute::v3_3_0::AssayConfiguration& assay_config() const;
  inline ::ib::ffi::compute::v3_3_0::AssayConfiguration* mutable_assay_config();
  inline ::ib::ffi::compute::v3_3_0::AssayConfiguration* release_assay_config();
  
  // repeated .ib.ffi.compute.v3_3_0.ConvertedSample converted_samples = 2;
  inline int converted_samples_size() const;
  inline void clear_converted_samples();
  static const int kConvertedSamplesFieldNumber = 2;
  inline const ::ib::ffi::compute::v3_3_0::ConvertedSample& converted_samples(int index) const;
  inline ::ib::ffi::compute::v3_3_0::ConvertedSample* mutable_converted_samples(int index);
  inline ::ib::ffi::compute::v3_3_0::ConvertedSample* add_converted_samples();
  inline const ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::ConvertedSample >&
      converted_samples() const;
  inline ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::ConvertedSample >*
      mutable_converted_samples();
  
  // @@protoc_insertion_point(class_scope:ib.ffi.compute.v3_3_0.FullSweepArgs)
 private:
  inline void set_has_assay_config();
  inline void clear_has_assay_config();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::ib::ffi::compute::v3_3_0::AssayConfiguration* assay_config_;
  ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::ConvertedSample > converted_samples_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_AssignDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_ShutdownFile_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  
  void InitAsDefaultInstance();
  static FullSweepArgs* default_instance_;
};
// -------------------------------------------------------------------

class FullSweepResult : public ::google::protobuf::Message {
 public:
  FullSweepResult();
  virtual ~FullSweepResult();
  
  FullSweepResult(const FullSweepResult& from);
  
  inline FullSweepResult& operator=(const FullSweepResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FullSweepResult& default_instance();
  
  void Swap(FullSweepResult* other);
  
  // implements Message ----------------------------------------------
  
  FullSweepResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FullSweepResult& from);
  void MergeFrom(const FullSweepResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .ib.ffi.compute.v3_3_0.QuantitatedSample quantitated_samples = 1;
  inline int quantitated_samples_size() const;
  inline void clear_quantitated_samples();
  static const int kQuantitatedSamplesFieldNumber = 1;
  inline const ::ib::ffi::compute::v3_3_0::QuantitatedSample& quantitated_samples(int index) const;
  inline ::ib::ffi::compute::v3_3_0::QuantitatedSample* mutable_quantitated_samples(int index);
  inline ::ib::ffi::compute::v3_3_0::QuantitatedSample* add_quantitated_samples();
  inline const ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedSample >&
      quantitated_samples() const;
  inline ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedSample >*
      mutable_quantitated_samples();
  
  // @@protoc_insertion_point(class_scope:ib.ffi.compute.v3_3_0.FullSweepResult)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedSample > quantitated_samples_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_AssignDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_ShutdownFile_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  
  void InitAsDefaultInstance();
  static FullSweepResult* default_instance_;
};
// -------------------------------------------------------------------

class AssayConfiguration : public ::google::protobuf::Message {
 public:
  AssayConfiguration();
  virtual ~AssayConfiguration();
  
  AssayConfiguration(const AssayConfiguration& from);
  
  inline AssayConfiguration& operator=(const AssayConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AssayConfiguration& default_instance();
  
  void Swap(AssayConfiguration* other);
  
  // implements Message ----------------------------------------------
  
  AssayConfiguration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssayConfiguration& from);
  void MergeFrom(const AssayConfiguration& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // @@protoc_insertion_point(class_scope:ib.ffi.compute.v3_3_0.AssayConfiguration)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_AssignDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_ShutdownFile_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  
  void InitAsDefaultInstance();
  static AssayConfiguration* default_instance_;
};
// -------------------------------------------------------------------

class QuantitatedSample : public ::google::protobuf::Message {
 public:
  QuantitatedSample();
  virtual ~QuantitatedSample();
  
  QuantitatedSample(const QuantitatedSample& from);
  
  inline QuantitatedSample& operator=(const QuantitatedSample& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const QuantitatedSample& default_instance();
  
  void Swap(QuantitatedSample* other);
  
  // implements Message ----------------------------------------------
  
  QuantitatedSample* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QuantitatedSample& from);
  void MergeFrom(const QuantitatedSample& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string unique_id = 3;
  inline bool has_unique_id() const;
  inline void clear_unique_id();
  static const int kUniqueIdFieldNumber = 3;
  inline const ::std::string& unique_id() const;
  inline void set_unique_id(const ::std::string& value);
  inline void set_unique_id(const char* value);
  inline void set_unique_id(const char* value, size_t size);
  inline ::std::string* mutable_unique_id();
  inline ::std::string* release_unique_id();
  
  // repeated .ib.ffi.compute.v3_3_0.QuantitatedCompound quantitated_compounds = 4;
  inline int quantitated_compounds_size() const;
  inline void clear_quantitated_compounds();
  static const int kQuantitatedCompoundsFieldNumber = 4;
  inline const ::ib::ffi::compute::v3_3_0::QuantitatedCompound& quantitated_compounds(int index) const;
  inline ::ib::ffi::compute::v3_3_0::QuantitatedCompound* mutable_quantitated_compounds(int index);
  inline ::ib::ffi::compute::v3_3_0::QuantitatedCompound* add_quantitated_compounds();
  inline const ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedCompound >&
      quantitated_compounds() const;
  inline ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedCompound >*
      mutable_quantitated_compounds();
  
  // @@protoc_insertion_point(class_scope:ib.ffi.compute.v3_3_0.QuantitatedSample)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_unique_id();
  inline void clear_has_unique_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::std::string* name_;
  ::std::string* unique_id_;
  ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedCompound > quantitated_compounds_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_AssignDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_ShutdownFile_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  
  void InitAsDefaultInstance();
  static QuantitatedSample* default_instance_;
};
// -------------------------------------------------------------------

class QuantitatedCompound : public ::google::protobuf::Message {
 public:
  QuantitatedCompound();
  virtual ~QuantitatedCompound();
  
  QuantitatedCompound(const QuantitatedCompound& from);
  
  inline QuantitatedCompound& operator=(const QuantitatedCompound& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const QuantitatedCompound& default_instance();
  
  void Swap(QuantitatedCompound* other);
  
  // implements Message ----------------------------------------------
  
  QuantitatedCompound* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QuantitatedCompound& from);
  void MergeFrom(const QuantitatedCompound& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated .ib.ffi.compute.v3_3_0.QuantitatedChromatogram quantitated_chromatograms = 3;
  inline int quantitated_chromatograms_size() const;
  inline void clear_quantitated_chromatograms();
  static const int kQuantitatedChromatogramsFieldNumber = 3;
  inline const ::ib::ffi::compute::v3_3_0::QuantitatedChromatogram& quantitated_chromatograms(int index) const;
  inline ::ib::ffi::compute::v3_3_0::QuantitatedChromatogram* mutable_quantitated_chromatograms(int index);
  inline ::ib::ffi::compute::v3_3_0::QuantitatedChromatogram* add_quantitated_chromatograms();
  inline const ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedChromatogram >&
      quantitated_chromatograms() const;
  inline ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedChromatogram >*
      mutable_quantitated_chromatograms();
  
  // @@protoc_insertion_point(class_scope:ib.ffi.compute.v3_3_0.QuantitatedCompound)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedChromatogram > quantitated_chromatograms_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_AssignDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_ShutdownFile_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  
  void InitAsDefaultInstance();
  static QuantitatedCompound* default_instance_;
};
// -------------------------------------------------------------------

class QuantitatedChromatogram : public ::google::protobuf::Message {
 public:
  QuantitatedChromatogram();
  virtual ~QuantitatedChromatogram();
  
  QuantitatedChromatogram(const QuantitatedChromatogram& from);
  
  inline QuantitatedChromatogram& operator=(const QuantitatedChromatogram& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const QuantitatedChromatogram& default_instance();
  
  void Swap(QuantitatedChromatogram* other);
  
  // implements Message ----------------------------------------------
  
  QuantitatedChromatogram* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QuantitatedChromatogram& from);
  void MergeFrom(const QuantitatedChromatogram& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // @@protoc_insertion_point(class_scope:ib.ffi.compute.v3_3_0.QuantitatedChromatogram)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::std::string* name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_AssignDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_ShutdownFile_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  
  void InitAsDefaultInstance();
  static QuantitatedChromatogram* default_instance_;
};
// -------------------------------------------------------------------

class ConvertedSample : public ::google::protobuf::Message {
 public:
  ConvertedSample();
  virtual ~ConvertedSample();
  
  ConvertedSample(const ConvertedSample& from);
  
  inline ConvertedSample& operator=(const ConvertedSample& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConvertedSample& default_instance();
  
  void Swap(ConvertedSample* other);
  
  // implements Message ----------------------------------------------
  
  ConvertedSample* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConvertedSample& from);
  void MergeFrom(const ConvertedSample& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required string unique_id = 2;
  inline bool has_unique_id() const;
  inline void clear_unique_id();
  static const int kUniqueIdFieldNumber = 2;
  inline const ::std::string& unique_id() const;
  inline void set_unique_id(const ::std::string& value);
  inline void set_unique_id(const char* value);
  inline void set_unique_id(const char* value, size_t size);
  inline ::std::string* mutable_unique_id();
  inline ::std::string* release_unique_id();
  
  // repeated .ib.ffi.compute.v3_3_0.ConvertedChromatogram converted_chromatograms = 3;
  inline int converted_chromatograms_size() const;
  inline void clear_converted_chromatograms();
  static const int kConvertedChromatogramsFieldNumber = 3;
  inline const ::ib::ffi::compute::v3_3_0::ConvertedChromatogram& converted_chromatograms(int index) const;
  inline ::ib::ffi::compute::v3_3_0::ConvertedChromatogram* mutable_converted_chromatograms(int index);
  inline ::ib::ffi::compute::v3_3_0::ConvertedChromatogram* add_converted_chromatograms();
  inline const ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::ConvertedChromatogram >&
      converted_chromatograms() const;
  inline ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::ConvertedChromatogram >*
      mutable_converted_chromatograms();
  
  // @@protoc_insertion_point(class_scope:ib.ffi.compute.v3_3_0.ConvertedSample)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_unique_id();
  inline void clear_has_unique_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::std::string* unique_id_;
  ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::ConvertedChromatogram > converted_chromatograms_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_AssignDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_ShutdownFile_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  
  void InitAsDefaultInstance();
  static ConvertedSample* default_instance_;
};
// -------------------------------------------------------------------

class ConvertedChromatogram : public ::google::protobuf::Message {
 public:
  ConvertedChromatogram();
  virtual ~ConvertedChromatogram();
  
  ConvertedChromatogram(const ConvertedChromatogram& from);
  
  inline ConvertedChromatogram& operator=(const ConvertedChromatogram& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConvertedChromatogram& default_instance();
  
  void Swap(ConvertedChromatogram* other);
  
  // implements Message ----------------------------------------------
  
  ConvertedChromatogram* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConvertedChromatogram& from);
  void MergeFrom(const ConvertedChromatogram& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // optional double precursor = 2;
  inline bool has_precursor() const;
  inline void clear_precursor();
  static const int kPrecursorFieldNumber = 2;
  inline double precursor() const;
  inline void set_precursor(double value);
  
  // required double product = 3;
  inline bool has_product() const;
  inline void clear_product();
  static const int kProductFieldNumber = 3;
  inline double product() const;
  inline void set_product(double value);
  
  // required string polarity = 4;
  inline bool has_polarity() const;
  inline void clear_polarity();
  static const int kPolarityFieldNumber = 4;
  inline const ::std::string& polarity() const;
  inline void set_polarity(const ::std::string& value);
  inline void set_polarity(const char* value);
  inline void set_polarity(const char* value, size_t size);
  inline ::std::string* mutable_polarity();
  inline ::std::string* release_polarity();
  
  // optional double collision_energy = 5;
  inline bool has_collision_energy() const;
  inline void clear_collision_energy();
  static const int kCollisionEnergyFieldNumber = 5;
  inline double collision_energy() const;
  inline void set_collision_energy(double value);
  
  // @@protoc_insertion_point(class_scope:ib.ffi.compute.v3_3_0.ConvertedChromatogram)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_precursor();
  inline void clear_has_precursor();
  inline void set_has_product();
  inline void clear_has_product();
  inline void set_has_polarity();
  inline void clear_has_polarity();
  inline void set_has_collision_energy();
  inline void clear_has_collision_energy();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  double precursor_;
  double product_;
  ::std::string* polarity_;
  double collision_energy_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_AssignDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_ShutdownFile_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  
  void InitAsDefaultInstance();
  static ConvertedChromatogram* default_instance_;
};
// ===================================================================


// ===================================================================

// FullSweepArgs

// required .ib.ffi.compute.v3_3_0.AssayConfiguration assay_config = 1;
inline bool FullSweepArgs::has_assay_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FullSweepArgs::set_has_assay_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FullSweepArgs::clear_has_assay_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FullSweepArgs::clear_assay_config() {
  if (assay_config_ != NULL) assay_config_->::ib::ffi::compute::v3_3_0::AssayConfiguration::Clear();
  clear_has_assay_config();
}
inline const ::ib::ffi::compute::v3_3_0::AssayConfiguration& FullSweepArgs::assay_config() const {
  return assay_config_ != NULL ? *assay_config_ : *default_instance_->assay_config_;
}
inline ::ib::ffi::compute::v3_3_0::AssayConfiguration* FullSweepArgs::mutable_assay_config() {
  set_has_assay_config();
  if (assay_config_ == NULL) assay_config_ = new ::ib::ffi::compute::v3_3_0::AssayConfiguration;
  return assay_config_;
}
inline ::ib::ffi::compute::v3_3_0::AssayConfiguration* FullSweepArgs::release_assay_config() {
  clear_has_assay_config();
  ::ib::ffi::compute::v3_3_0::AssayConfiguration* temp = assay_config_;
  assay_config_ = NULL;
  return temp;
}

// repeated .ib.ffi.compute.v3_3_0.ConvertedSample converted_samples = 2;
inline int FullSweepArgs::converted_samples_size() const {
  return converted_samples_.size();
}
inline void FullSweepArgs::clear_converted_samples() {
  converted_samples_.Clear();
}
inline const ::ib::ffi::compute::v3_3_0::ConvertedSample& FullSweepArgs::converted_samples(int index) const {
  return converted_samples_.Get(index);
}
inline ::ib::ffi::compute::v3_3_0::ConvertedSample* FullSweepArgs::mutable_converted_samples(int index) {
  return converted_samples_.Mutable(index);
}
inline ::ib::ffi::compute::v3_3_0::ConvertedSample* FullSweepArgs::add_converted_samples() {
  return converted_samples_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::ConvertedSample >&
FullSweepArgs::converted_samples() const {
  return converted_samples_;
}
inline ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::ConvertedSample >*
FullSweepArgs::mutable_converted_samples() {
  return &converted_samples_;
}

// -------------------------------------------------------------------

// FullSweepResult

// repeated .ib.ffi.compute.v3_3_0.QuantitatedSample quantitated_samples = 1;
inline int FullSweepResult::quantitated_samples_size() const {
  return quantitated_samples_.size();
}
inline void FullSweepResult::clear_quantitated_samples() {
  quantitated_samples_.Clear();
}
inline const ::ib::ffi::compute::v3_3_0::QuantitatedSample& FullSweepResult::quantitated_samples(int index) const {
  return quantitated_samples_.Get(index);
}
inline ::ib::ffi::compute::v3_3_0::QuantitatedSample* FullSweepResult::mutable_quantitated_samples(int index) {
  return quantitated_samples_.Mutable(index);
}
inline ::ib::ffi::compute::v3_3_0::QuantitatedSample* FullSweepResult::add_quantitated_samples() {
  return quantitated_samples_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedSample >&
FullSweepResult::quantitated_samples() const {
  return quantitated_samples_;
}
inline ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedSample >*
FullSweepResult::mutable_quantitated_samples() {
  return &quantitated_samples_;
}

// -------------------------------------------------------------------

// AssayConfiguration

// required string name = 1;
inline bool AssayConfiguration::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AssayConfiguration::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AssayConfiguration::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AssayConfiguration::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AssayConfiguration::name() const {
  return *name_;
}
inline void AssayConfiguration::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AssayConfiguration::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AssayConfiguration::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AssayConfiguration::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AssayConfiguration::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// QuantitatedSample

// required string id = 1;
inline bool QuantitatedSample::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuantitatedSample::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuantitatedSample::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuantitatedSample::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& QuantitatedSample::id() const {
  return *id_;
}
inline void QuantitatedSample::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void QuantitatedSample::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void QuantitatedSample::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuantitatedSample::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* QuantitatedSample::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string name = 2;
inline bool QuantitatedSample::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QuantitatedSample::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QuantitatedSample::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QuantitatedSample::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& QuantitatedSample::name() const {
  return *name_;
}
inline void QuantitatedSample::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void QuantitatedSample::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void QuantitatedSample::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuantitatedSample::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* QuantitatedSample::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string unique_id = 3;
inline bool QuantitatedSample::has_unique_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QuantitatedSample::set_has_unique_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QuantitatedSample::clear_has_unique_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QuantitatedSample::clear_unique_id() {
  if (unique_id_ != &::google::protobuf::internal::kEmptyString) {
    unique_id_->clear();
  }
  clear_has_unique_id();
}
inline const ::std::string& QuantitatedSample::unique_id() const {
  return *unique_id_;
}
inline void QuantitatedSample::set_unique_id(const ::std::string& value) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(value);
}
inline void QuantitatedSample::set_unique_id(const char* value) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(value);
}
inline void QuantitatedSample::set_unique_id(const char* value, size_t size) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuantitatedSample::mutable_unique_id() {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  return unique_id_;
}
inline ::std::string* QuantitatedSample::release_unique_id() {
  clear_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = unique_id_;
    unique_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .ib.ffi.compute.v3_3_0.QuantitatedCompound quantitated_compounds = 4;
inline int QuantitatedSample::quantitated_compounds_size() const {
  return quantitated_compounds_.size();
}
inline void QuantitatedSample::clear_quantitated_compounds() {
  quantitated_compounds_.Clear();
}
inline const ::ib::ffi::compute::v3_3_0::QuantitatedCompound& QuantitatedSample::quantitated_compounds(int index) const {
  return quantitated_compounds_.Get(index);
}
inline ::ib::ffi::compute::v3_3_0::QuantitatedCompound* QuantitatedSample::mutable_quantitated_compounds(int index) {
  return quantitated_compounds_.Mutable(index);
}
inline ::ib::ffi::compute::v3_3_0::QuantitatedCompound* QuantitatedSample::add_quantitated_compounds() {
  return quantitated_compounds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedCompound >&
QuantitatedSample::quantitated_compounds() const {
  return quantitated_compounds_;
}
inline ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedCompound >*
QuantitatedSample::mutable_quantitated_compounds() {
  return &quantitated_compounds_;
}

// -------------------------------------------------------------------

// QuantitatedCompound

// required string id = 1;
inline bool QuantitatedCompound::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuantitatedCompound::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuantitatedCompound::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuantitatedCompound::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& QuantitatedCompound::id() const {
  return *id_;
}
inline void QuantitatedCompound::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void QuantitatedCompound::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void QuantitatedCompound::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuantitatedCompound::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* QuantitatedCompound::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string name = 2;
inline bool QuantitatedCompound::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QuantitatedCompound::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QuantitatedCompound::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QuantitatedCompound::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& QuantitatedCompound::name() const {
  return *name_;
}
inline void QuantitatedCompound::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void QuantitatedCompound::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void QuantitatedCompound::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuantitatedCompound::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* QuantitatedCompound::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .ib.ffi.compute.v3_3_0.QuantitatedChromatogram quantitated_chromatograms = 3;
inline int QuantitatedCompound::quantitated_chromatograms_size() const {
  return quantitated_chromatograms_.size();
}
inline void QuantitatedCompound::clear_quantitated_chromatograms() {
  quantitated_chromatograms_.Clear();
}
inline const ::ib::ffi::compute::v3_3_0::QuantitatedChromatogram& QuantitatedCompound::quantitated_chromatograms(int index) const {
  return quantitated_chromatograms_.Get(index);
}
inline ::ib::ffi::compute::v3_3_0::QuantitatedChromatogram* QuantitatedCompound::mutable_quantitated_chromatograms(int index) {
  return quantitated_chromatograms_.Mutable(index);
}
inline ::ib::ffi::compute::v3_3_0::QuantitatedChromatogram* QuantitatedCompound::add_quantitated_chromatograms() {
  return quantitated_chromatograms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedChromatogram >&
QuantitatedCompound::quantitated_chromatograms() const {
  return quantitated_chromatograms_;
}
inline ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedChromatogram >*
QuantitatedCompound::mutable_quantitated_chromatograms() {
  return &quantitated_chromatograms_;
}

// -------------------------------------------------------------------

// QuantitatedChromatogram

// required string id = 1;
inline bool QuantitatedChromatogram::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuantitatedChromatogram::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuantitatedChromatogram::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuantitatedChromatogram::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& QuantitatedChromatogram::id() const {
  return *id_;
}
inline void QuantitatedChromatogram::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void QuantitatedChromatogram::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void QuantitatedChromatogram::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuantitatedChromatogram::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* QuantitatedChromatogram::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string name = 2;
inline bool QuantitatedChromatogram::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QuantitatedChromatogram::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QuantitatedChromatogram::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QuantitatedChromatogram::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& QuantitatedChromatogram::name() const {
  return *name_;
}
inline void QuantitatedChromatogram::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void QuantitatedChromatogram::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void QuantitatedChromatogram::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuantitatedChromatogram::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* QuantitatedChromatogram::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ConvertedSample

// required string id = 1;
inline bool ConvertedSample::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConvertedSample::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConvertedSample::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConvertedSample::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ConvertedSample::id() const {
  return *id_;
}
inline void ConvertedSample::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ConvertedSample::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ConvertedSample::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConvertedSample::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ConvertedSample::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string unique_id = 2;
inline bool ConvertedSample::has_unique_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConvertedSample::set_has_unique_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConvertedSample::clear_has_unique_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConvertedSample::clear_unique_id() {
  if (unique_id_ != &::google::protobuf::internal::kEmptyString) {
    unique_id_->clear();
  }
  clear_has_unique_id();
}
inline const ::std::string& ConvertedSample::unique_id() const {
  return *unique_id_;
}
inline void ConvertedSample::set_unique_id(const ::std::string& value) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(value);
}
inline void ConvertedSample::set_unique_id(const char* value) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(value);
}
inline void ConvertedSample::set_unique_id(const char* value, size_t size) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConvertedSample::mutable_unique_id() {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  return unique_id_;
}
inline ::std::string* ConvertedSample::release_unique_id() {
  clear_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = unique_id_;
    unique_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .ib.ffi.compute.v3_3_0.ConvertedChromatogram converted_chromatograms = 3;
inline int ConvertedSample::converted_chromatograms_size() const {
  return converted_chromatograms_.size();
}
inline void ConvertedSample::clear_converted_chromatograms() {
  converted_chromatograms_.Clear();
}
inline const ::ib::ffi::compute::v3_3_0::ConvertedChromatogram& ConvertedSample::converted_chromatograms(int index) const {
  return converted_chromatograms_.Get(index);
}
inline ::ib::ffi::compute::v3_3_0::ConvertedChromatogram* ConvertedSample::mutable_converted_chromatograms(int index) {
  return converted_chromatograms_.Mutable(index);
}
inline ::ib::ffi::compute::v3_3_0::ConvertedChromatogram* ConvertedSample::add_converted_chromatograms() {
  return converted_chromatograms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::ConvertedChromatogram >&
ConvertedSample::converted_chromatograms() const {
  return converted_chromatograms_;
}
inline ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::ConvertedChromatogram >*
ConvertedSample::mutable_converted_chromatograms() {
  return &converted_chromatograms_;
}

// -------------------------------------------------------------------

// ConvertedChromatogram

// required string id = 1;
inline bool ConvertedChromatogram::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConvertedChromatogram::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConvertedChromatogram::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConvertedChromatogram::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ConvertedChromatogram::id() const {
  return *id_;
}
inline void ConvertedChromatogram::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ConvertedChromatogram::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ConvertedChromatogram::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConvertedChromatogram::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ConvertedChromatogram::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double precursor = 2;
inline bool ConvertedChromatogram::has_precursor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConvertedChromatogram::set_has_precursor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConvertedChromatogram::clear_has_precursor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConvertedChromatogram::clear_precursor() {
  precursor_ = 0;
  clear_has_precursor();
}
inline double ConvertedChromatogram::precursor() const {
  return precursor_;
}
inline void ConvertedChromatogram::set_precursor(double value) {
  set_has_precursor();
  precursor_ = value;
}

// required double product = 3;
inline bool ConvertedChromatogram::has_product() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConvertedChromatogram::set_has_product() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConvertedChromatogram::clear_has_product() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConvertedChromatogram::clear_product() {
  product_ = 0;
  clear_has_product();
}
inline double ConvertedChromatogram::product() const {
  return product_;
}
inline void ConvertedChromatogram::set_product(double value) {
  set_has_product();
  product_ = value;
}

// required string polarity = 4;
inline bool ConvertedChromatogram::has_polarity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConvertedChromatogram::set_has_polarity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConvertedChromatogram::clear_has_polarity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConvertedChromatogram::clear_polarity() {
  if (polarity_ != &::google::protobuf::internal::kEmptyString) {
    polarity_->clear();
  }
  clear_has_polarity();
}
inline const ::std::string& ConvertedChromatogram::polarity() const {
  return *polarity_;
}
inline void ConvertedChromatogram::set_polarity(const ::std::string& value) {
  set_has_polarity();
  if (polarity_ == &::google::protobuf::internal::kEmptyString) {
    polarity_ = new ::std::string;
  }
  polarity_->assign(value);
}
inline void ConvertedChromatogram::set_polarity(const char* value) {
  set_has_polarity();
  if (polarity_ == &::google::protobuf::internal::kEmptyString) {
    polarity_ = new ::std::string;
  }
  polarity_->assign(value);
}
inline void ConvertedChromatogram::set_polarity(const char* value, size_t size) {
  set_has_polarity();
  if (polarity_ == &::google::protobuf::internal::kEmptyString) {
    polarity_ = new ::std::string;
  }
  polarity_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConvertedChromatogram::mutable_polarity() {
  set_has_polarity();
  if (polarity_ == &::google::protobuf::internal::kEmptyString) {
    polarity_ = new ::std::string;
  }
  return polarity_;
}
inline ::std::string* ConvertedChromatogram::release_polarity() {
  clear_has_polarity();
  if (polarity_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = polarity_;
    polarity_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double collision_energy = 5;
inline bool ConvertedChromatogram::has_collision_energy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ConvertedChromatogram::set_has_collision_energy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ConvertedChromatogram::clear_has_collision_energy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ConvertedChromatogram::clear_collision_energy() {
  collision_energy_ = 0;
  clear_has_collision_energy();
}
inline double ConvertedChromatogram::collision_energy() const {
  return collision_energy_;
}
inline void ConvertedChromatogram::set_collision_energy(double value) {
  set_has_collision_energy();
  collision_energy_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace v3_3_0
}  // namespace compute
}  // namespace ffi
}  // namespace ib

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto__INCLUDED
