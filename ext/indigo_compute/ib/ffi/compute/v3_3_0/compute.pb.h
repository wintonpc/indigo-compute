// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ib/ffi/compute/v3_3_0/compute.proto

#ifndef PROTOBUF_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto__INCLUDED
#define PROTOBUF_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace ib {
namespace ffi {
namespace compute {
namespace v3_3_0 {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
void protobuf_AssignDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
void protobuf_ShutdownFile_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();

class FullSweepArgs;
class FullSweepResult;
class AssayConfiguration;
class QuantitatedSample;
class QuantitatedCompound;
class QuantitatedChromatogram;
class ConvertedSample;
class ConvertedChromatogram;

// ===================================================================

class FullSweepArgs : public ::google::protobuf::Message {
 public:
  FullSweepArgs();
  virtual ~FullSweepArgs();
  
  FullSweepArgs(const FullSweepArgs& from);
  
  inline FullSweepArgs& operator=(const FullSweepArgs& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FullSweepArgs& default_instance();
  
  void Swap(FullSweepArgs* other);
  
  // implements Message ----------------------------------------------
  
  FullSweepArgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FullSweepArgs& from);
  void MergeFrom(const FullSweepArgs& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .ib.ffi.compute.v3_3_0.AssayConfiguration assayConfig = 1;
  inline bool has_assayconfig() const;
  inline void clear_assayconfig();
  static const int kAssayConfigFieldNumber = 1;
  inline const ::ib::ffi::compute::v3_3_0::AssayConfiguration& assayconfig() const;
  inline ::ib::ffi::compute::v3_3_0::AssayConfiguration* mutable_assayconfig();
  inline ::ib::ffi::compute::v3_3_0::AssayConfiguration* release_assayconfig();
  
  // repeated .ib.ffi.compute.v3_3_0.ConvertedSample convertedSamples = 2;
  inline int convertedsamples_size() const;
  inline void clear_convertedsamples();
  static const int kConvertedSamplesFieldNumber = 2;
  inline const ::ib::ffi::compute::v3_3_0::ConvertedSample& convertedsamples(int index) const;
  inline ::ib::ffi::compute::v3_3_0::ConvertedSample* mutable_convertedsamples(int index);
  inline ::ib::ffi::compute::v3_3_0::ConvertedSample* add_convertedsamples();
  inline const ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::ConvertedSample >&
      convertedsamples() const;
  inline ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::ConvertedSample >*
      mutable_convertedsamples();
  
  // @@protoc_insertion_point(class_scope:ib.ffi.compute.v3_3_0.FullSweepArgs)
 private:
  inline void set_has_assayconfig();
  inline void clear_has_assayconfig();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::ib::ffi::compute::v3_3_0::AssayConfiguration* assayconfig_;
  ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::ConvertedSample > convertedsamples_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_AssignDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_ShutdownFile_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  
  void InitAsDefaultInstance();
  static FullSweepArgs* default_instance_;
};
// -------------------------------------------------------------------

class FullSweepResult : public ::google::protobuf::Message {
 public:
  FullSweepResult();
  virtual ~FullSweepResult();
  
  FullSweepResult(const FullSweepResult& from);
  
  inline FullSweepResult& operator=(const FullSweepResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FullSweepResult& default_instance();
  
  void Swap(FullSweepResult* other);
  
  // implements Message ----------------------------------------------
  
  FullSweepResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FullSweepResult& from);
  void MergeFrom(const FullSweepResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .ib.ffi.compute.v3_3_0.QuantitatedSample quantitatedSamples = 1;
  inline int quantitatedsamples_size() const;
  inline void clear_quantitatedsamples();
  static const int kQuantitatedSamplesFieldNumber = 1;
  inline const ::ib::ffi::compute::v3_3_0::QuantitatedSample& quantitatedsamples(int index) const;
  inline ::ib::ffi::compute::v3_3_0::QuantitatedSample* mutable_quantitatedsamples(int index);
  inline ::ib::ffi::compute::v3_3_0::QuantitatedSample* add_quantitatedsamples();
  inline const ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedSample >&
      quantitatedsamples() const;
  inline ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedSample >*
      mutable_quantitatedsamples();
  
  // @@protoc_insertion_point(class_scope:ib.ffi.compute.v3_3_0.FullSweepResult)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedSample > quantitatedsamples_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_AssignDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_ShutdownFile_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  
  void InitAsDefaultInstance();
  static FullSweepResult* default_instance_;
};
// -------------------------------------------------------------------

class AssayConfiguration : public ::google::protobuf::Message {
 public:
  AssayConfiguration();
  virtual ~AssayConfiguration();
  
  AssayConfiguration(const AssayConfiguration& from);
  
  inline AssayConfiguration& operator=(const AssayConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AssayConfiguration& default_instance();
  
  void Swap(AssayConfiguration* other);
  
  // implements Message ----------------------------------------------
  
  AssayConfiguration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssayConfiguration& from);
  void MergeFrom(const AssayConfiguration& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // @@protoc_insertion_point(class_scope:ib.ffi.compute.v3_3_0.AssayConfiguration)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_AssignDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_ShutdownFile_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  
  void InitAsDefaultInstance();
  static AssayConfiguration* default_instance_;
};
// -------------------------------------------------------------------

class QuantitatedSample : public ::google::protobuf::Message {
 public:
  QuantitatedSample();
  virtual ~QuantitatedSample();
  
  QuantitatedSample(const QuantitatedSample& from);
  
  inline QuantitatedSample& operator=(const QuantitatedSample& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const QuantitatedSample& default_instance();
  
  void Swap(QuantitatedSample* other);
  
  // implements Message ----------------------------------------------
  
  QuantitatedSample* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QuantitatedSample& from);
  void MergeFrom(const QuantitatedSample& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string unique_id = 3;
  inline bool has_unique_id() const;
  inline void clear_unique_id();
  static const int kUniqueIdFieldNumber = 3;
  inline const ::std::string& unique_id() const;
  inline void set_unique_id(const ::std::string& value);
  inline void set_unique_id(const char* value);
  inline void set_unique_id(const char* value, size_t size);
  inline ::std::string* mutable_unique_id();
  inline ::std::string* release_unique_id();
  
  // repeated .ib.ffi.compute.v3_3_0.QuantitatedCompound quantitatedCompounds = 4;
  inline int quantitatedcompounds_size() const;
  inline void clear_quantitatedcompounds();
  static const int kQuantitatedCompoundsFieldNumber = 4;
  inline const ::ib::ffi::compute::v3_3_0::QuantitatedCompound& quantitatedcompounds(int index) const;
  inline ::ib::ffi::compute::v3_3_0::QuantitatedCompound* mutable_quantitatedcompounds(int index);
  inline ::ib::ffi::compute::v3_3_0::QuantitatedCompound* add_quantitatedcompounds();
  inline const ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedCompound >&
      quantitatedcompounds() const;
  inline ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedCompound >*
      mutable_quantitatedcompounds();
  
  // @@protoc_insertion_point(class_scope:ib.ffi.compute.v3_3_0.QuantitatedSample)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_unique_id();
  inline void clear_has_unique_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::std::string* name_;
  ::std::string* unique_id_;
  ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedCompound > quantitatedcompounds_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_AssignDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_ShutdownFile_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  
  void InitAsDefaultInstance();
  static QuantitatedSample* default_instance_;
};
// -------------------------------------------------------------------

class QuantitatedCompound : public ::google::protobuf::Message {
 public:
  QuantitatedCompound();
  virtual ~QuantitatedCompound();
  
  QuantitatedCompound(const QuantitatedCompound& from);
  
  inline QuantitatedCompound& operator=(const QuantitatedCompound& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const QuantitatedCompound& default_instance();
  
  void Swap(QuantitatedCompound* other);
  
  // implements Message ----------------------------------------------
  
  QuantitatedCompound* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QuantitatedCompound& from);
  void MergeFrom(const QuantitatedCompound& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated .ib.ffi.compute.v3_3_0.QuantitatedChromatogram quantitatedChromatograms = 3;
  inline int quantitatedchromatograms_size() const;
  inline void clear_quantitatedchromatograms();
  static const int kQuantitatedChromatogramsFieldNumber = 3;
  inline const ::ib::ffi::compute::v3_3_0::QuantitatedChromatogram& quantitatedchromatograms(int index) const;
  inline ::ib::ffi::compute::v3_3_0::QuantitatedChromatogram* mutable_quantitatedchromatograms(int index);
  inline ::ib::ffi::compute::v3_3_0::QuantitatedChromatogram* add_quantitatedchromatograms();
  inline const ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedChromatogram >&
      quantitatedchromatograms() const;
  inline ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedChromatogram >*
      mutable_quantitatedchromatograms();
  
  // @@protoc_insertion_point(class_scope:ib.ffi.compute.v3_3_0.QuantitatedCompound)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedChromatogram > quantitatedchromatograms_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_AssignDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_ShutdownFile_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  
  void InitAsDefaultInstance();
  static QuantitatedCompound* default_instance_;
};
// -------------------------------------------------------------------

class QuantitatedChromatogram : public ::google::protobuf::Message {
 public:
  QuantitatedChromatogram();
  virtual ~QuantitatedChromatogram();
  
  QuantitatedChromatogram(const QuantitatedChromatogram& from);
  
  inline QuantitatedChromatogram& operator=(const QuantitatedChromatogram& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const QuantitatedChromatogram& default_instance();
  
  void Swap(QuantitatedChromatogram* other);
  
  // implements Message ----------------------------------------------
  
  QuantitatedChromatogram* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QuantitatedChromatogram& from);
  void MergeFrom(const QuantitatedChromatogram& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // @@protoc_insertion_point(class_scope:ib.ffi.compute.v3_3_0.QuantitatedChromatogram)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::std::string* name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_AssignDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_ShutdownFile_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  
  void InitAsDefaultInstance();
  static QuantitatedChromatogram* default_instance_;
};
// -------------------------------------------------------------------

class ConvertedSample : public ::google::protobuf::Message {
 public:
  ConvertedSample();
  virtual ~ConvertedSample();
  
  ConvertedSample(const ConvertedSample& from);
  
  inline ConvertedSample& operator=(const ConvertedSample& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConvertedSample& default_instance();
  
  void Swap(ConvertedSample* other);
  
  // implements Message ----------------------------------------------
  
  ConvertedSample* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConvertedSample& from);
  void MergeFrom(const ConvertedSample& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string unique_id = 3;
  inline bool has_unique_id() const;
  inline void clear_unique_id();
  static const int kUniqueIdFieldNumber = 3;
  inline const ::std::string& unique_id() const;
  inline void set_unique_id(const ::std::string& value);
  inline void set_unique_id(const char* value);
  inline void set_unique_id(const char* value, size_t size);
  inline ::std::string* mutable_unique_id();
  inline ::std::string* release_unique_id();
  
  // repeated .ib.ffi.compute.v3_3_0.ConvertedChromatogram convertedChromatograms = 4;
  inline int convertedchromatograms_size() const;
  inline void clear_convertedchromatograms();
  static const int kConvertedChromatogramsFieldNumber = 4;
  inline const ::ib::ffi::compute::v3_3_0::ConvertedChromatogram& convertedchromatograms(int index) const;
  inline ::ib::ffi::compute::v3_3_0::ConvertedChromatogram* mutable_convertedchromatograms(int index);
  inline ::ib::ffi::compute::v3_3_0::ConvertedChromatogram* add_convertedchromatograms();
  inline const ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::ConvertedChromatogram >&
      convertedchromatograms() const;
  inline ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::ConvertedChromatogram >*
      mutable_convertedchromatograms();
  
  // @@protoc_insertion_point(class_scope:ib.ffi.compute.v3_3_0.ConvertedSample)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_unique_id();
  inline void clear_has_unique_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::std::string* name_;
  ::std::string* unique_id_;
  ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::ConvertedChromatogram > convertedchromatograms_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_AssignDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_ShutdownFile_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  
  void InitAsDefaultInstance();
  static ConvertedSample* default_instance_;
};
// -------------------------------------------------------------------

class ConvertedChromatogram : public ::google::protobuf::Message {
 public:
  ConvertedChromatogram();
  virtual ~ConvertedChromatogram();
  
  ConvertedChromatogram(const ConvertedChromatogram& from);
  
  inline ConvertedChromatogram& operator=(const ConvertedChromatogram& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConvertedChromatogram& default_instance();
  
  void Swap(ConvertedChromatogram* other);
  
  // implements Message ----------------------------------------------
  
  ConvertedChromatogram* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConvertedChromatogram& from);
  void MergeFrom(const ConvertedChromatogram& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // optional double precursor = 2;
  inline bool has_precursor() const;
  inline void clear_precursor();
  static const int kPrecursorFieldNumber = 2;
  inline double precursor() const;
  inline void set_precursor(double value);
  
  // required double product = 3;
  inline bool has_product() const;
  inline void clear_product();
  static const int kProductFieldNumber = 3;
  inline double product() const;
  inline void set_product(double value);
  
  // required string polarity = 4;
  inline bool has_polarity() const;
  inline void clear_polarity();
  static const int kPolarityFieldNumber = 4;
  inline const ::std::string& polarity() const;
  inline void set_polarity(const ::std::string& value);
  inline void set_polarity(const char* value);
  inline void set_polarity(const char* value, size_t size);
  inline ::std::string* mutable_polarity();
  inline ::std::string* release_polarity();
  
  // optional double collisionEnergy = 5;
  inline bool has_collisionenergy() const;
  inline void clear_collisionenergy();
  static const int kCollisionEnergyFieldNumber = 5;
  inline double collisionenergy() const;
  inline void set_collisionenergy(double value);
  
  // @@protoc_insertion_point(class_scope:ib.ffi.compute.v3_3_0.ConvertedChromatogram)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_precursor();
  inline void clear_has_precursor();
  inline void set_has_product();
  inline void clear_has_product();
  inline void set_has_polarity();
  inline void clear_has_polarity();
  inline void set_has_collisionenergy();
  inline void clear_has_collisionenergy();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  double precursor_;
  double product_;
  ::std::string* polarity_;
  double collisionenergy_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_AssignDesc_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  friend void protobuf_ShutdownFile_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto();
  
  void InitAsDefaultInstance();
  static ConvertedChromatogram* default_instance_;
};
// ===================================================================


// ===================================================================

// FullSweepArgs

// required .ib.ffi.compute.v3_3_0.AssayConfiguration assayConfig = 1;
inline bool FullSweepArgs::has_assayconfig() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FullSweepArgs::set_has_assayconfig() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FullSweepArgs::clear_has_assayconfig() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FullSweepArgs::clear_assayconfig() {
  if (assayconfig_ != NULL) assayconfig_->::ib::ffi::compute::v3_3_0::AssayConfiguration::Clear();
  clear_has_assayconfig();
}
inline const ::ib::ffi::compute::v3_3_0::AssayConfiguration& FullSweepArgs::assayconfig() const {
  return assayconfig_ != NULL ? *assayconfig_ : *default_instance_->assayconfig_;
}
inline ::ib::ffi::compute::v3_3_0::AssayConfiguration* FullSweepArgs::mutable_assayconfig() {
  set_has_assayconfig();
  if (assayconfig_ == NULL) assayconfig_ = new ::ib::ffi::compute::v3_3_0::AssayConfiguration;
  return assayconfig_;
}
inline ::ib::ffi::compute::v3_3_0::AssayConfiguration* FullSweepArgs::release_assayconfig() {
  clear_has_assayconfig();
  ::ib::ffi::compute::v3_3_0::AssayConfiguration* temp = assayconfig_;
  assayconfig_ = NULL;
  return temp;
}

// repeated .ib.ffi.compute.v3_3_0.ConvertedSample convertedSamples = 2;
inline int FullSweepArgs::convertedsamples_size() const {
  return convertedsamples_.size();
}
inline void FullSweepArgs::clear_convertedsamples() {
  convertedsamples_.Clear();
}
inline const ::ib::ffi::compute::v3_3_0::ConvertedSample& FullSweepArgs::convertedsamples(int index) const {
  return convertedsamples_.Get(index);
}
inline ::ib::ffi::compute::v3_3_0::ConvertedSample* FullSweepArgs::mutable_convertedsamples(int index) {
  return convertedsamples_.Mutable(index);
}
inline ::ib::ffi::compute::v3_3_0::ConvertedSample* FullSweepArgs::add_convertedsamples() {
  return convertedsamples_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::ConvertedSample >&
FullSweepArgs::convertedsamples() const {
  return convertedsamples_;
}
inline ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::ConvertedSample >*
FullSweepArgs::mutable_convertedsamples() {
  return &convertedsamples_;
}

// -------------------------------------------------------------------

// FullSweepResult

// repeated .ib.ffi.compute.v3_3_0.QuantitatedSample quantitatedSamples = 1;
inline int FullSweepResult::quantitatedsamples_size() const {
  return quantitatedsamples_.size();
}
inline void FullSweepResult::clear_quantitatedsamples() {
  quantitatedsamples_.Clear();
}
inline const ::ib::ffi::compute::v3_3_0::QuantitatedSample& FullSweepResult::quantitatedsamples(int index) const {
  return quantitatedsamples_.Get(index);
}
inline ::ib::ffi::compute::v3_3_0::QuantitatedSample* FullSweepResult::mutable_quantitatedsamples(int index) {
  return quantitatedsamples_.Mutable(index);
}
inline ::ib::ffi::compute::v3_3_0::QuantitatedSample* FullSweepResult::add_quantitatedsamples() {
  return quantitatedsamples_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedSample >&
FullSweepResult::quantitatedsamples() const {
  return quantitatedsamples_;
}
inline ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedSample >*
FullSweepResult::mutable_quantitatedsamples() {
  return &quantitatedsamples_;
}

// -------------------------------------------------------------------

// AssayConfiguration

// required string name = 1;
inline bool AssayConfiguration::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AssayConfiguration::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AssayConfiguration::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AssayConfiguration::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AssayConfiguration::name() const {
  return *name_;
}
inline void AssayConfiguration::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AssayConfiguration::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AssayConfiguration::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AssayConfiguration::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AssayConfiguration::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// QuantitatedSample

// required string id = 1;
inline bool QuantitatedSample::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuantitatedSample::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuantitatedSample::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuantitatedSample::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& QuantitatedSample::id() const {
  return *id_;
}
inline void QuantitatedSample::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void QuantitatedSample::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void QuantitatedSample::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuantitatedSample::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* QuantitatedSample::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string name = 2;
inline bool QuantitatedSample::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QuantitatedSample::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QuantitatedSample::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QuantitatedSample::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& QuantitatedSample::name() const {
  return *name_;
}
inline void QuantitatedSample::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void QuantitatedSample::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void QuantitatedSample::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuantitatedSample::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* QuantitatedSample::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string unique_id = 3;
inline bool QuantitatedSample::has_unique_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QuantitatedSample::set_has_unique_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QuantitatedSample::clear_has_unique_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QuantitatedSample::clear_unique_id() {
  if (unique_id_ != &::google::protobuf::internal::kEmptyString) {
    unique_id_->clear();
  }
  clear_has_unique_id();
}
inline const ::std::string& QuantitatedSample::unique_id() const {
  return *unique_id_;
}
inline void QuantitatedSample::set_unique_id(const ::std::string& value) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(value);
}
inline void QuantitatedSample::set_unique_id(const char* value) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(value);
}
inline void QuantitatedSample::set_unique_id(const char* value, size_t size) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuantitatedSample::mutable_unique_id() {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  return unique_id_;
}
inline ::std::string* QuantitatedSample::release_unique_id() {
  clear_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = unique_id_;
    unique_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .ib.ffi.compute.v3_3_0.QuantitatedCompound quantitatedCompounds = 4;
inline int QuantitatedSample::quantitatedcompounds_size() const {
  return quantitatedcompounds_.size();
}
inline void QuantitatedSample::clear_quantitatedcompounds() {
  quantitatedcompounds_.Clear();
}
inline const ::ib::ffi::compute::v3_3_0::QuantitatedCompound& QuantitatedSample::quantitatedcompounds(int index) const {
  return quantitatedcompounds_.Get(index);
}
inline ::ib::ffi::compute::v3_3_0::QuantitatedCompound* QuantitatedSample::mutable_quantitatedcompounds(int index) {
  return quantitatedcompounds_.Mutable(index);
}
inline ::ib::ffi::compute::v3_3_0::QuantitatedCompound* QuantitatedSample::add_quantitatedcompounds() {
  return quantitatedcompounds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedCompound >&
QuantitatedSample::quantitatedcompounds() const {
  return quantitatedcompounds_;
}
inline ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedCompound >*
QuantitatedSample::mutable_quantitatedcompounds() {
  return &quantitatedcompounds_;
}

// -------------------------------------------------------------------

// QuantitatedCompound

// required string id = 1;
inline bool QuantitatedCompound::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuantitatedCompound::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuantitatedCompound::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuantitatedCompound::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& QuantitatedCompound::id() const {
  return *id_;
}
inline void QuantitatedCompound::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void QuantitatedCompound::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void QuantitatedCompound::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuantitatedCompound::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* QuantitatedCompound::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string name = 2;
inline bool QuantitatedCompound::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QuantitatedCompound::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QuantitatedCompound::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QuantitatedCompound::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& QuantitatedCompound::name() const {
  return *name_;
}
inline void QuantitatedCompound::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void QuantitatedCompound::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void QuantitatedCompound::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuantitatedCompound::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* QuantitatedCompound::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .ib.ffi.compute.v3_3_0.QuantitatedChromatogram quantitatedChromatograms = 3;
inline int QuantitatedCompound::quantitatedchromatograms_size() const {
  return quantitatedchromatograms_.size();
}
inline void QuantitatedCompound::clear_quantitatedchromatograms() {
  quantitatedchromatograms_.Clear();
}
inline const ::ib::ffi::compute::v3_3_0::QuantitatedChromatogram& QuantitatedCompound::quantitatedchromatograms(int index) const {
  return quantitatedchromatograms_.Get(index);
}
inline ::ib::ffi::compute::v3_3_0::QuantitatedChromatogram* QuantitatedCompound::mutable_quantitatedchromatograms(int index) {
  return quantitatedchromatograms_.Mutable(index);
}
inline ::ib::ffi::compute::v3_3_0::QuantitatedChromatogram* QuantitatedCompound::add_quantitatedchromatograms() {
  return quantitatedchromatograms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedChromatogram >&
QuantitatedCompound::quantitatedchromatograms() const {
  return quantitatedchromatograms_;
}
inline ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::QuantitatedChromatogram >*
QuantitatedCompound::mutable_quantitatedchromatograms() {
  return &quantitatedchromatograms_;
}

// -------------------------------------------------------------------

// QuantitatedChromatogram

// required string id = 1;
inline bool QuantitatedChromatogram::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuantitatedChromatogram::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuantitatedChromatogram::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuantitatedChromatogram::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& QuantitatedChromatogram::id() const {
  return *id_;
}
inline void QuantitatedChromatogram::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void QuantitatedChromatogram::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void QuantitatedChromatogram::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuantitatedChromatogram::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* QuantitatedChromatogram::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string name = 2;
inline bool QuantitatedChromatogram::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QuantitatedChromatogram::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QuantitatedChromatogram::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QuantitatedChromatogram::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& QuantitatedChromatogram::name() const {
  return *name_;
}
inline void QuantitatedChromatogram::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void QuantitatedChromatogram::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void QuantitatedChromatogram::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuantitatedChromatogram::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* QuantitatedChromatogram::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ConvertedSample

// required string id = 1;
inline bool ConvertedSample::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConvertedSample::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConvertedSample::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConvertedSample::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ConvertedSample::id() const {
  return *id_;
}
inline void ConvertedSample::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ConvertedSample::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ConvertedSample::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConvertedSample::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ConvertedSample::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string name = 2;
inline bool ConvertedSample::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConvertedSample::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConvertedSample::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConvertedSample::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ConvertedSample::name() const {
  return *name_;
}
inline void ConvertedSample::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ConvertedSample::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ConvertedSample::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConvertedSample::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ConvertedSample::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string unique_id = 3;
inline bool ConvertedSample::has_unique_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConvertedSample::set_has_unique_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConvertedSample::clear_has_unique_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConvertedSample::clear_unique_id() {
  if (unique_id_ != &::google::protobuf::internal::kEmptyString) {
    unique_id_->clear();
  }
  clear_has_unique_id();
}
inline const ::std::string& ConvertedSample::unique_id() const {
  return *unique_id_;
}
inline void ConvertedSample::set_unique_id(const ::std::string& value) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(value);
}
inline void ConvertedSample::set_unique_id(const char* value) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(value);
}
inline void ConvertedSample::set_unique_id(const char* value, size_t size) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConvertedSample::mutable_unique_id() {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  return unique_id_;
}
inline ::std::string* ConvertedSample::release_unique_id() {
  clear_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = unique_id_;
    unique_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .ib.ffi.compute.v3_3_0.ConvertedChromatogram convertedChromatograms = 4;
inline int ConvertedSample::convertedchromatograms_size() const {
  return convertedchromatograms_.size();
}
inline void ConvertedSample::clear_convertedchromatograms() {
  convertedchromatograms_.Clear();
}
inline const ::ib::ffi::compute::v3_3_0::ConvertedChromatogram& ConvertedSample::convertedchromatograms(int index) const {
  return convertedchromatograms_.Get(index);
}
inline ::ib::ffi::compute::v3_3_0::ConvertedChromatogram* ConvertedSample::mutable_convertedchromatograms(int index) {
  return convertedchromatograms_.Mutable(index);
}
inline ::ib::ffi::compute::v3_3_0::ConvertedChromatogram* ConvertedSample::add_convertedchromatograms() {
  return convertedchromatograms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::ConvertedChromatogram >&
ConvertedSample::convertedchromatograms() const {
  return convertedchromatograms_;
}
inline ::google::protobuf::RepeatedPtrField< ::ib::ffi::compute::v3_3_0::ConvertedChromatogram >*
ConvertedSample::mutable_convertedchromatograms() {
  return &convertedchromatograms_;
}

// -------------------------------------------------------------------

// ConvertedChromatogram

// required string id = 1;
inline bool ConvertedChromatogram::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConvertedChromatogram::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConvertedChromatogram::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConvertedChromatogram::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ConvertedChromatogram::id() const {
  return *id_;
}
inline void ConvertedChromatogram::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ConvertedChromatogram::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ConvertedChromatogram::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConvertedChromatogram::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ConvertedChromatogram::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double precursor = 2;
inline bool ConvertedChromatogram::has_precursor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConvertedChromatogram::set_has_precursor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConvertedChromatogram::clear_has_precursor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConvertedChromatogram::clear_precursor() {
  precursor_ = 0;
  clear_has_precursor();
}
inline double ConvertedChromatogram::precursor() const {
  return precursor_;
}
inline void ConvertedChromatogram::set_precursor(double value) {
  set_has_precursor();
  precursor_ = value;
}

// required double product = 3;
inline bool ConvertedChromatogram::has_product() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConvertedChromatogram::set_has_product() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConvertedChromatogram::clear_has_product() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConvertedChromatogram::clear_product() {
  product_ = 0;
  clear_has_product();
}
inline double ConvertedChromatogram::product() const {
  return product_;
}
inline void ConvertedChromatogram::set_product(double value) {
  set_has_product();
  product_ = value;
}

// required string polarity = 4;
inline bool ConvertedChromatogram::has_polarity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConvertedChromatogram::set_has_polarity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConvertedChromatogram::clear_has_polarity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConvertedChromatogram::clear_polarity() {
  if (polarity_ != &::google::protobuf::internal::kEmptyString) {
    polarity_->clear();
  }
  clear_has_polarity();
}
inline const ::std::string& ConvertedChromatogram::polarity() const {
  return *polarity_;
}
inline void ConvertedChromatogram::set_polarity(const ::std::string& value) {
  set_has_polarity();
  if (polarity_ == &::google::protobuf::internal::kEmptyString) {
    polarity_ = new ::std::string;
  }
  polarity_->assign(value);
}
inline void ConvertedChromatogram::set_polarity(const char* value) {
  set_has_polarity();
  if (polarity_ == &::google::protobuf::internal::kEmptyString) {
    polarity_ = new ::std::string;
  }
  polarity_->assign(value);
}
inline void ConvertedChromatogram::set_polarity(const char* value, size_t size) {
  set_has_polarity();
  if (polarity_ == &::google::protobuf::internal::kEmptyString) {
    polarity_ = new ::std::string;
  }
  polarity_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConvertedChromatogram::mutable_polarity() {
  set_has_polarity();
  if (polarity_ == &::google::protobuf::internal::kEmptyString) {
    polarity_ = new ::std::string;
  }
  return polarity_;
}
inline ::std::string* ConvertedChromatogram::release_polarity() {
  clear_has_polarity();
  if (polarity_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = polarity_;
    polarity_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double collisionEnergy = 5;
inline bool ConvertedChromatogram::has_collisionenergy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ConvertedChromatogram::set_has_collisionenergy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ConvertedChromatogram::clear_has_collisionenergy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ConvertedChromatogram::clear_collisionenergy() {
  collisionenergy_ = 0;
  clear_has_collisionenergy();
}
inline double ConvertedChromatogram::collisionenergy() const {
  return collisionenergy_;
}
inline void ConvertedChromatogram::set_collisionenergy(double value) {
  set_has_collisionenergy();
  collisionenergy_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace v3_3_0
}  // namespace compute
}  // namespace ffi
}  // namespace ib

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ib_2fffi_2fcompute_2fv3_5f3_5f0_2fcompute_2eproto__INCLUDED
